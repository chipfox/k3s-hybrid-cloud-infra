# PROJECT KNOWLEDGE BASE

**Generated:** 2026-02-11
**Commit:** eb2035c
**Branch:** main

## OVERVIEW

Infrastructure-as-code for hybrid Kubernetes: Proxmox VMs + AWS EKS with k3s bootstrapped via Ansible.

## ARCHITECTURE — ONE-BUTTON DEPLOYMENT

This project is a **fully automated, zero-manual-step deployment pipeline**. From a single IaC source tree, running `terraform apply` + `ansible-playbook` produces a complete Kubernetes cluster with ArgoCD continuously deploying and reconciling all application workloads. No manual `kubectl apply`, no clicking through UIs, no post-deploy scripts.

### Deployment Pipeline (Proxmox / k3s)

```
terraform apply (proxmox)
  ├─ Provisions VMs via Proxmox API (cloud-init: packages, users, networking)
  ├─ Generates Ansible inventory → k3s-ansible/inventory.ini
  └─ Deploys ArgoCD via Helm into the k3s cluster (namespace, chart, values, admin password)
        │
        └─ ArgoCD bootstrap Application (gitops/bootstrap/argocd-bootstrap.yaml)
              ├─ Syncs ApplicationSets for cluster addons  (gitops/addons/)
              ├─ Syncs ApplicationSets for workloads       (gitops/workloads/)
              └─ Registers cluster secrets                 (gitops/clusters/)
                    │
                    └─ Workloads auto-deploy and self-heal from git
                          └─ Application pods running ✓
```

**Between Terraform and ArgoCD**, Ansible bootstraps k3s:

```
ansible-playbook playbook.yaml
  ├─ Installs k3s-ansible collection (k3s-io/k3s-ansible via requirement.yaml)
  └─ Runs site.yml → k3s server + agent nodes join cluster
```

### Deployment Pipeline (AWS EKS)

```
terraform apply (aws-eks)
  ├─ Creates VPC (3-AZ, subnets, NAT gateway)
  ├─ Creates EKS cluster + managed node group
  ├─ Creates IRSA roles for ArgoCD (controller + repo-server)
  └─ Deploys ArgoCD via Helm (IRSA-backed, Secrets Manager integration)
        └─ Same ArgoCD bootstrap → ApplicationSets → running workloads
```

### GitOps Layer (ArgoCD App-of-Apps)

ArgoCD is deployed **by Terraform** and pointed at this repo. The bootstrap chain is:

1. **Bootstrap App** — `gitops/bootstrap/argocd-bootstrap.yaml` syncs itself into ArgoCD.
2. **Addons ApplicationSet** — `gitops/addons/addons-applicationset.yaml` deploys cluster addons across all registered clusters.
3. **Workloads ApplicationSet** — `gitops/workloads/workloads-applicationset.yaml` deploys application workloads (e.g., guestbook) to clusters labeled `environment: production`.
4. **Cluster Secrets** — `gitops/clusters/{k3s-proxmox,eks-aws}.yaml` register target clusters with ArgoCD.

All ArgoCD Applications use `automated` sync with `prune: true` and `selfHeal: true`. Git is the single source of truth — push a change, ArgoCD converges the cluster.

### Design Principles

- **Zero manual steps**: Every resource — VMs, cluster, ArgoCD, workloads — is defined in code.
- **Idempotent**: Re-running `terraform apply` or `ansible-playbook` converges to the same state.
- **GitOps-native**: Application lifecycle managed entirely through git commits; ArgoCD handles deploy, rollback, and drift correction.
- **Standard toolchain**: Terraform + Ansible + ArgoCD is a widely-adopted pattern for Kubernetes platform engineering. No custom tooling.
- **Hybrid-ready**: Same ArgoCD bootstrap pattern works across on-prem (Proxmox/k3s) and cloud (AWS EKS).

### Code Philosophy

- **Code is the documentation**: Any engineer should understand what a `.tf`, `.yaml`, or playbook does by reading the code alone. If you need a README to explain what a resource does, the code is too complex — simplify it.
- **Clean and minimalist**: No dead code, no commented-out blocks left behind, no over-abstracted modules. Every file, variable, and resource must earn its place.
- **Self-evident naming**: Resource names, variable names, and file names must convey intent without external explanation. `k3s_server`, `argocd_namespace`, `inventory.tpl` — not `resource1`, `ns`, `tpl`.
- **Flat over nested**: Prefer straightforward resource definitions over deeply nested modules or abstractions. One level of module indirection is acceptable; two requires justification.
- **Standardized secrets handling**:
  - Proxmox: Secrets in `.auto.tfvars` (git-ignored). SSH keys in `keys/` (git-ignored). ArgoCD admin password bcrypt-hashed at apply time.
  - AWS: Secrets via `TF_VAR_` environment variables or AWS Secrets Manager. IRSA for pod-level access — never static credentials in code.
  - Ansible: SSH key path configured in `ansible.cfg`, key generated by Terraform. k3s token in `group_vars/all.yaml` (git-ignored or vault-encrypted).
  - **Rule**: No secret value ever appears in committed code, state files, or plan output.
- **Consistent patterns**: Both Proxmox and AWS EKS roots follow the same structure (`main.tf`, `variables.tf`, `outputs.tf`, `argocd.tf`) and the same ArgoCD bootstrap pattern. Learn one, understand both.
- **Readable diffs**: Changes should produce clean, reviewable git diffs. Avoid reformatting unrelated code in the same commit.

## STRUCTURE

```
./
├── terraform/proxmox/      # Proxmox VM provisioning + inventory generation
├── terraform/aws-eks/      # AWS EKS cluster + VPC
├── k3s-ansible/            # Ansible runner for k3s-ansible collection
└── .github/workflows/      # Opencode comment-triggered automation
```

## WHERE TO LOOK

| Task | Location | Notes |
|------|----------|-------|
| Proxmox VM specs/IPs/IDs | terraform/proxmox/{variables,locals}.tf | Naming, IP bases, VM ID bases live here |
| Proxmox VM resources | terraform/proxmox/main.tf | VM definitions + cloud-init integration |
| Inventory generation | terraform/proxmox/inventory.tf + inventory.tpl | Writes ../k3s-ansible/inventory.ini |
| AWS EKS/VPC config | terraform/aws-eks/main.tf | Uses terraform-aws-modules (vpc/eks) |
| k3s install/playbooks | k3s-ansible/playbook.yaml | Installs collection + imports site.yml |
| k3s settings | k3s-ansible/group_vars/all.yaml | Version/token/user settings |
| Operational runbooks | terraform/**/README.md | Proxmox/AWS usage + prerequisites |
| Verification checklist | terraform/proxmox/CONFIGURATION_CHECKLIST.md | Post-apply validation steps, maintain it too. |
| Known fixes | terraform/proxmox/FIXES_APPLIED.md | Historical issues + resolutions |

## CONVENTIONS

- Proxmox uses `.auto.tfvars` locally; secrets never committed.
- AWS secrets set via `TF_VAR_bootstrap_secret_value` environment variable.
- Proxmox VM naming: `k3st-#` servers, `k3st-a#` agents; VM IDs 200+ and 300+ respectively.
- Proxmox storage references use storage IDs (not filesystem paths).

## ANTI-PATTERNS (THIS PROJECT)

- Do not commit `.tfvars`, `*.tfstate`, or SSH keys.
- Do not enable root login on VMs; use `vm_user` + sudo.
- Do not overlap server/agent IP ranges or VM ID ranges.
- Do not define user/network in both cloud-init and Proxmox `initialization` blocks.

## UNIQUE STYLES

- Terraform Proxmox writes Ansible inventory into `k3s-ansible/` (cross-dir coupling is intentional).
- Proxmox has a dedicated verification checklist and fixes log; treat as operational ground truth.

## COMMANDS

```bash
cd terraform/proxmox && terraform init && terraform plan && terraform apply -auto-approve -parallelism=2
cd terraform/aws-eks && terraform init && terraform plan && terraform apply -auto-approve -parallelism=2
cd k3s-ansible && ansible-playbook playbook.yaml
```

## NOTES

- Proxmox template VM must include `qemu-guest-agent` for correct IP reporting.
- Opencode GitHub workflow triggers via PR/issue comments (`/oc`, `/opencode`).

## OPENCODE OPERATIONAL PHILOSOPHY

### 1. OPERATIONAL DIRECTIVES (DEFAULT MODE)

- Follow instructions: Execute the request immediately. Do not deviate.
- Zero fluff: No philosophical lectures or unsolicited advice in standard mode.
- Stay focused: Concise answers only. No wandering.
- Output first: Prioritize code and visual solutions.
- Tooling priority: Prefer agents, `openskills`, and tools before freeform narrative.
- Escalate early: If anything approaches a blocker, delegate to agents or subagents immediately. Do not spin on a problem alone.
- Delegate down: Route trivial or mechanical tasks (file renames, formatting, simple searches, boilerplate generation) to smaller/cheaper model agents. Reserve the primary model for decisions, architecture, and complex reasoning.
- Equip subagents: When delegating to any agent or subagent, specify which tools it should use (e.g., `grep_search`, `read_file`, `run_in_terminal`). Do not send a subagent off with only a vague description — include the tool names, file paths, and expected output format.
- No auto-summary docs: Do not create summary documents for every task.
- Task tracking: Maintain a todo list file only when needed.

### 2. THE "ULTRATHINK" PROTOCOL (TRIGGER COMMAND)

**TRIGGER:** When the user prompts `ULTRATHINK`.

- Override brevity: Immediately suspend the "Zero Fluff" rule.
- Maximum depth: Engage in exhaustive, deep-level reasoning.
- Multi-dimensional analysis required:
  - Psychological: User sentiment and cognitive load.
  - Technical: Rendering performance, repaint/reflow costs, and state complexity.
  - Accessibility: WCAG AAA strictness.
  - Scalability: Long-term maintenance and modularity.
- Prohibition: Never use surface-level logic; if reasoning feels easy, continue until the logic is irrefutable.

<skills_system priority="1">

## Available Skills

<!-- SKILLS_TABLE_START -->
<usage>
When users ask you to perform tasks, check if any of the available skills below can help complete the task more effectively. Skills provide specialized capabilities and domain knowledge.

How to use skills:

- Invoke: Bash("openskills read <skill-name>")
- The skill content will load with detailed instructions on how to complete the task
- Base directory provided in output for resolving bundled resources (references/, scripts/, assets/)

Usage notes:

- Only use skills listed in <available_skills> below
- Do not invoke a skill that is already loaded in your context
- Each skill invocation is stateless
</usage>

<available_skills>

<skill>
<name>artifacts-builder</name>
<description>Suite of tools for creating elaborate, multi-component claude.ai HTML artifacts using modern frontend web technologies (React, Tailwind CSS, shadcn/ui). Use for complex artifacts requiring state management, routing, or shadcn/ui components - not for simple single-file HTML/JSX artifacts.</description>
<location>global</location>
</skill>

<skill>
<name>artifacts-builder-windows</name>
<description>Windows-compatible suite of tools for creating elaborate, multi-component claude.ai HTML artifacts using modern frontend web technologies (React, Tailwind CSS, shadcn/ui). Use for complex artifacts requiring state management, routing, or shadcn/ui components on Windows systems - not for simple single-file HTML/JSX artifacts.</description>
<location>global</location>
</skill>

<skill>
<name>brainstorming</name>
<description>Use when creating or developing, before writing code or implementation plans - refines rough ideas into fully-formed designs through collaborative questioning, alternative exploration, and incremental validation. Don't use during clear 'mechanical' processes</description>
<location>global</location>
</skill>

<skill>
<name>browsing-windows</name>
<description>Windows-compatible browser automation using Chrome remote debugging with PowerShell. Launch Chrome with WebSocket debugging enabled for programmatic browser control. Use when you need to automate browser interactions, take screenshots, or test web applications on Windows.</description>
<location>global</location>
</skill>

<skill>
<name>executing-plans</name>
<description>Use when partner provides a complete implementation plan to execute in controlled batches with review checkpoints - loads plan, reviews critically, executes tasks in batches, reports for review between batches</description>
<location>global</location>
</skill>

<skill>
<name>finishing-a-development-branch-windows</name>
<description>Windows-compatible guide for safely completing development branches with proper git workflows including testing, building, and cleanup. Use when finishing feature branches, preparing for merge/PR, or ensuring code quality before integration on Windows systems.</description>
<location>global</location>
</skill>

<skill>
<name>internal-comms</name>
<description>A set of resources to help me write all kinds of internal communications, using the formats that my company likes to use. Claude should use this skill whenever asked to write some sort of internal communications (status reports, leadership updates, 3P updates, company newsletters, FAQs, incident reports, project updates, etc.).</description>
<location>global</location>
</skill>

<skill>
<name>mcp-builder</name>
<description>Guide for creating high-quality MCP (Model Context Protocol) servers that enable LLMs to interact with external services through well-designed tools. Use when building MCP servers to integrate external APIs or services, whether in Python (FastMCP) or Node/TypeScript (MCP SDK).</description>
<location>global</location>
</skill>

<skill>
<name>product-design-system</name>
<description>This skill should be used when designing product UIs from concept through implementation. It guides users through a structured 5-stage design process—from product requirements discovery to React + Tailwind implementation—ensuring design and UX are validated before any complex backend logic or authentication is built.</description>
<location>global</location>
</skill>

<skill>
<name>receiving-code-review</name>
<description>Use when receiving code review feedback, before implementing suggestions, especially if feedback seems unclear or technically questionable - requires technical rigor and verification, not performative agreement or blind implementation</description>
<location>global</location>
</skill>

<skill>
<name>requesting-code-review</name>
<description>Use when completing tasks, implementing major features, or before merging to verify work meets requirements - dispatches superpowers:code-reviewer subagent to review implementation against plan or requirements before proceeding</description>
<location>global</location>
</skill>

<skill>
<name>root-cause-tracing</name>
<description>Use when errors occur deep in execution and you need to trace back to find the original trigger - systematically traces bugs backward through call stack, adding instrumentation when needed, to identify source of invalid data or incorrect behavior</description>
<location>global</location>
</skill>

<skill>
<name>root-cause-tracing-windows</name>
<description>Windows-compatible tool for tracing root causes using pattern detection in test output. Uses git bisect and PowerShell to identify commits that introduced specific failures or debug output patterns. Use when debugging test failures or unexpected behavior on Windows systems.</description>
<location>global</location>
</skill>

<skill>
<name>skill-creator</name>
<description>Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.</description>
<location>global</location>
</skill>

<skill>
<name>systematic-debugging</name>
<description>Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes - four-phase framework (root cause investigation, pattern analysis, hypothesis testing, implementation) that ensures understanding before attempting solutions</description>
<location>global</location>
</skill>

<skill>
<name>template-skill</name>
<description>Replace with description of the skill and when Claude should use it.</description>
<location>global</location>
</skill>

<skill>
<name>test-driven-development</name>
<description>Use when implementing any feature or bugfix, before writing implementation code - write the test first, watch it fail, write minimal code to pass; ensures tests actually verify behavior by requiring failure first</description>
<location>global</location>
</skill>

<skill>
<name>testing-anti-patterns</name>
<description>Use when writing or changing tests, adding mocks, or tempted to add test-only methods to production code - prevents testing mock behavior, production pollution with test-only methods, and mocking without understanding dependencies</description>
<location>global</location>
</skill>

<skill>
<name>testing-skills-with-subagents</name>
<description>Use when creating or editing skills, before deployment, to verify they work under pressure and resist rationalization - applies RED-GREEN-REFACTOR cycle to process documentation by running baseline without skill, writing to address failures, iterating to close loopholes</description>
<location>global</location>
</skill>

<skill>
<name>using-git-worktrees</name>
<description>Use when starting feature work that needs isolation from current workspace or before executing implementation plans - creates isolated git worktrees with smart directory selection and safety verification</description>
<location>global</location>
</skill>

<skill>
<name>using-superpowers</name>
<description>Use when starting any conversation - establishes mandatory workflows for finding and using skills, including using Skill tool before announcing usage, following brainstorming before coding, and creating TodoWrite todos for checklists</description>
<location>global</location>
</skill>

<skill>
<name>verification-before-completion</name>
<description>Use when about to claim work is complete, fixed, or passing, before committing or creating PRs - requires running verification commands and confirming output before making any success claims; evidence before assertions always</description>
<location>global</location>
</skill>

<skill>
<name>webapp-testing</name>
<description>Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.</description>
<location>global</location>
</skill>

<skill>
<name>writing-plans</name>
<description>Use when design is complete and you need detailed implementation tasks for engineers with zero codebase context - creates comprehensive implementation plans with exact file paths, complete code examples, and verification steps assuming engineer has minimal domain knowledge</description>
<location>global</location>
</skill>

<skill>
<name>writing-skills</name>
<description>Use when creating new skills, editing existing skills, or verifying skills work before deployment - applies TDD to process documentation by testing with subagents before writing, iterating until bulletproof against rationalization</description>
<location>global</location>
</skill>

</available_skills>
<!-- SKILLS_TABLE_END -->

</skills_system>
